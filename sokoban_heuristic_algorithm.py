# Load the search_astar_algorithm.py
import search_astar_algorithm as astar

# Load the board_game_setup.py
from board_game_setup import *

# Load the numpy package and the state is represented as a numpy array during this homework.
import numpy as np


# a_star perform the A* algorithm with the start_state (numpy array), goal_test (function), successors (function) and
# heuristic (function). a_star prints the solution from start_state to goal_state (path), calculates the number of
# generated nodes (node_generated) and expanded nodes (node_expanded), and the solution depth (len(path)-1). a_star
# also provides the following functions for printing states and moves: prettyMoves(path): Translate the solution to a
# list of moves printlists(path): Visualize the solution and Print a list of states
def a_star(start_state, goal_test, successors, heuristic):
    goal_node, node_generated, node_expanded = astar.a_star_search(
        start_state, goal_test, successors, heuristic)
    if goal_node:
        node = goal_node
        path = [node.state1]
        while node.parent:
            node = node.parent
            path.append(node.state1)
        path.reverse()

        # print('My path:{}'.format(path))
        # print(prettyMoves(path))
        # printlists(path)
        print('Nodes Generated by A*: {}'.format(node_generated))
        print('Nodes Expanded by A*: {}'.format(node_expanded))
        print('Solution Depth: {}'.format(len(path) - 1))
    else:
        print('no solution found')


# A shortcut function
# Transform the input state to numpy array. For other functions, the state s is presented as a numpy array.
# Goal-test and next-states stay the same throughout the assignment
# You can just call sokoban(init-state, heuristic function) to test the result
def sokoban(s, h):
    return a_star(np.array(s), goal_test, next_states, h)

# h0 computes the trivial admissible heuristic


def h0(s):
    return 0

# count_num_boxes is a helper function of h1 function
# it takes in 3 args, state, row, and col
# count_num_boxes returns the number of boxes are misplaced by checking the box at each (r, c)


def count_num_boxes(state, row, col):

    num_boxes = 0

    for r in range(row):
        for c in range(col):
            if isBox(state[r, c]):
                num_boxes += 1

    return num_boxes

# h1 takes in a state and return the number of boxes that are not on the goal position
# h1 is heuristic admissible because it considered all the misplaced boxes.
# h1 can only count how many boxes on the board and cannt get over the number of misplaced boxes.


def h1(s):
    # get row and col of the board
    row, col = s.shape[0], s.shape[1]

    # return number of misplaced boxes
    return count_num_boxes(s, row, col)

# get_list_boxes_position takes in 3 args, state, row, and col
# it returns the list of boxes after traversing through the number of row and col


def get_list_boxes_position(state, row, col):
    list_boxes = list()

    for r in range(row):
        for c in range(col):
            if isBox(state[r, c]):
                list_boxes.append((r, c))

    return list_boxes

# get_list_stars_position takes in 3 args, state, row, and col
# it returns the list of stars after traversing through the number of row and col


def get_list_stars_position(state, row, col):
    list_stars = list()

    for r in range(row):
        for c in range(col):
            if isStar(state[r, c]):
                list_stars.append((r, c))

    return list_stars

# distance takes in 2 args, num1 and num2
# distance returns the absolute values of the distance between num1 and num2


def distance(num1, num2):
    return np.absolute(num1 - num2)

# calculate_distance_keeper_to_box is a helper function for h405784956
# calculate_distance_keeper_to_box takes in state as an argument
# it returns the distance of the keeper to the box


def calculate_distance_keeper_to_boxgoal(state):

    row, col = state.shape[0], state.shape[1]

    count_distance = 0

    list_boxes = get_list_boxes_position(state, row, col)

    list_star = get_list_stars_position(state, row, col)

    keeper_row, keeper_col = tuple(getKeeperPosition(state))

    box_to_star = 1

    for box in list_boxes:

        count_distance += distance(keeper_row,
                                   box[0]) + distance(keeper_col, box[1])

        for star in list_star:
            distance_box_to_star = distance(
                box[0], star[0]) + distance(box[1], star[1])

            if distance_box_to_star < box_to_star:
                box_to_star = distance_box_to_star

        count_distance += box_to_star

    return count_distance

# heuristic_optimal_func return the distance from the keeper to the boxgoal that calculates from the distance between the keeper to the box


def heuristic_optimal_func(s):
    return calculate_distance_keeper_to_boxgoal(s)